{"ast":null,"code":"import { useRef, useCallback } from 'react';\nimport { isNodeOrChild } from './utils/is-node-or-child.mjs';\nimport { addPointerEvent, usePointerEvent } from '../events/use-pointer-event.mjs';\nimport { useUnmountEffect } from '../utils/use-unmount-effect.mjs';\nimport { AnimationType } from '../render/utils/types.mjs';\nimport { isDragActive } from './drag/utils/lock.mjs';\nimport { pipe } from '../utils/pipe.mjs';\nimport { addDomEvent, useDomEvent } from '../events/use-dom-event.mjs';\nimport { extractEventInfo } from '../events/event-info.mjs';\nfunction fireSyntheticPointerEvent(name, handler) {\n  if (!handler) return;\n  const syntheticPointerEvent = new PointerEvent(\"pointer\" + name);\n  handler(syntheticPointerEvent, extractEventInfo(syntheticPointerEvent));\n}\n/**\n * @param handlers -\n * @internal\n */\nfunction useTapGesture(_ref) {\n  let {\n    onTap,\n    onTapStart,\n    onTapCancel,\n    whileTap,\n    visualElement,\n    ...props\n  } = _ref;\n  const hasPressListeners = onTap || onTapStart || onTapCancel || whileTap;\n  const isPressing = useRef(false);\n  const cancelPointerEndListeners = useRef(null);\n  const suspendedTabIndex = useRef(null);\n  /**\n   * Only set listener to passive if there are no external listeners.\n   */\n  const eventOptions = {\n    passive: !(onTapStart || onTap || onTapCancel || props[\"onPointerDown\"])\n  };\n  function removePointerEndListener() {\n    cancelPointerEndListeners.current && cancelPointerEndListeners.current();\n    cancelPointerEndListeners.current = null;\n  }\n  function checkPointerEnd() {\n    removePointerEndListener();\n    isPressing.current = false;\n    const latestProps = visualElement.getProps();\n    if (latestProps.whileTap && visualElement.animationState) {\n      visualElement.animationState.setActive(AnimationType.Tap, false);\n    }\n    if (suspendedTabIndex.current !== null) {\n      visualElement.current.setAttribute(\"tabindex\", suspendedTabIndex.current);\n    }\n    return !isDragActive();\n  }\n  function onPointerUp(event, info) {\n    var _a, _b, _c, _d;\n    if (!checkPointerEnd()) return;\n    /**\n     * We only count this as a tap gesture if the event.target is the same\n     * as, or a child of, this component's element\n     */\n    !isNodeOrChild(visualElement.current, event.target) ? (_b = (_a = visualElement.getProps()).onTapCancel) === null || _b === void 0 ? void 0 : _b.call(_a, event, info) : (_d = (_c = visualElement.getProps()).onTap) === null || _d === void 0 ? void 0 : _d.call(_c, event, info);\n  }\n  function onPointerCancel(event, info) {\n    var _a, _b;\n    if (!checkPointerEnd()) return;\n    (_b = (_a = visualElement.getProps()).onTapCancel) === null || _b === void 0 ? void 0 : _b.call(_a, event, info);\n  }\n  function onPointerStart(event, info) {\n    var _a;\n    const latestProps = visualElement.getProps();\n    /**\n     * Ensure we trigger animations before firing event callback\n     */\n    if (latestProps.whileTap && visualElement.animationState) {\n      visualElement.animationState.setActive(AnimationType.Tap, true);\n    }\n    (_a = latestProps.onTapStart) === null || _a === void 0 ? void 0 : _a.call(latestProps, event, info);\n  }\n  const callbackDependencies = [Boolean(onTapStart), Boolean(onTap), Boolean(whileTap), visualElement];\n  const startPress = useCallback((event, info) => {\n    removePointerEndListener();\n    if (isPressing.current) return;\n    isPressing.current = true;\n    suspendedTabIndex.current = visualElement.current.getAttribute(\"tabindex\");\n    visualElement.current.setAttribute(\"tabindex\", \"-1\");\n    cancelPointerEndListeners.current = pipe(addPointerEvent(window, \"pointerup\", onPointerUp, eventOptions), addPointerEvent(window, \"pointercancel\", onPointerCancel, eventOptions));\n    onPointerStart(event, info);\n  }, callbackDependencies);\n  usePointerEvent(visualElement, \"pointerdown\", hasPressListeners ? startPress : undefined, eventOptions);\n  const startAccessiblePress = useCallback(() => {\n    const stopKeydownListener = addDomEvent(visualElement.current, \"keydown\", event => {\n      if (event.key !== \"Enter\" || isPressing.current) return;\n      isPressing.current = true;\n      cancelPointerEndListeners.current = addDomEvent(visualElement.current, \"keyup\", () => {\n        if (event.key !== \"Enter\" || !checkPointerEnd()) return;\n        fireSyntheticPointerEvent(\"up\", visualElement.getProps().onTap);\n      }, eventOptions);\n      fireSyntheticPointerEvent(\"down\", onPointerStart);\n    });\n    const stopBlurListener = addDomEvent(visualElement.current, \"blur\", () => {\n      stopKeydownListener();\n      stopBlurListener();\n      if (isPressing.current) {\n        fireSyntheticPointerEvent(\"cancel\", onPointerCancel);\n      }\n    });\n  }, callbackDependencies);\n  useDomEvent(visualElement, \"focus\", hasPressListeners ? startAccessiblePress : undefined);\n  useUnmountEffect(removePointerEndListener);\n}\nexport { useTapGesture };","map":{"version":3,"names":["useRef","useCallback","isNodeOrChild","addPointerEvent","usePointerEvent","useUnmountEffect","AnimationType","isDragActive","pipe","addDomEvent","useDomEvent","extractEventInfo","fireSyntheticPointerEvent","name","handler","syntheticPointerEvent","PointerEvent","useTapGesture","onTap","onTapStart","onTapCancel","whileTap","visualElement","props","hasPressListeners","isPressing","cancelPointerEndListeners","suspendedTabIndex","eventOptions","passive","removePointerEndListener","current","checkPointerEnd","latestProps","getProps","animationState","setActive","Tap","setAttribute","onPointerUp","event","info","_a","_b","_c","_d","target","call","onPointerCancel","onPointerStart","callbackDependencies","Boolean","startPress","getAttribute","window","undefined","startAccessiblePress","stopKeydownListener","key","stopBlurListener"],"sources":["D:/react/groceryShop/node_modules/framer-motion/dist/es/gestures/use-tap-gesture.mjs"],"sourcesContent":["import { useRef, useCallback } from 'react';\nimport { isNodeOrChild } from './utils/is-node-or-child.mjs';\nimport { addPointerEvent, usePointerEvent } from '../events/use-pointer-event.mjs';\nimport { useUnmountEffect } from '../utils/use-unmount-effect.mjs';\nimport { AnimationType } from '../render/utils/types.mjs';\nimport { isDragActive } from './drag/utils/lock.mjs';\nimport { pipe } from '../utils/pipe.mjs';\nimport { addDomEvent, useDomEvent } from '../events/use-dom-event.mjs';\nimport { extractEventInfo } from '../events/event-info.mjs';\n\nfunction fireSyntheticPointerEvent(name, handler) {\n    if (!handler)\n        return;\n    const syntheticPointerEvent = new PointerEvent(\"pointer\" + name);\n    handler(syntheticPointerEvent, extractEventInfo(syntheticPointerEvent));\n}\n/**\n * @param handlers -\n * @internal\n */\nfunction useTapGesture({ onTap, onTapStart, onTapCancel, whileTap, visualElement, ...props }) {\n    const hasPressListeners = onTap || onTapStart || onTapCancel || whileTap;\n    const isPressing = useRef(false);\n    const cancelPointerEndListeners = useRef(null);\n    const suspendedTabIndex = useRef(null);\n    /**\n     * Only set listener to passive if there are no external listeners.\n     */\n    const eventOptions = {\n        passive: !(onTapStart ||\n            onTap ||\n            onTapCancel ||\n            props[\"onPointerDown\"]),\n    };\n    function removePointerEndListener() {\n        cancelPointerEndListeners.current && cancelPointerEndListeners.current();\n        cancelPointerEndListeners.current = null;\n    }\n    function checkPointerEnd() {\n        removePointerEndListener();\n        isPressing.current = false;\n        const latestProps = visualElement.getProps();\n        if (latestProps.whileTap && visualElement.animationState) {\n            visualElement.animationState.setActive(AnimationType.Tap, false);\n        }\n        if (suspendedTabIndex.current !== null) {\n            visualElement.current.setAttribute(\"tabindex\", suspendedTabIndex.current);\n        }\n        return !isDragActive();\n    }\n    function onPointerUp(event, info) {\n        var _a, _b, _c, _d;\n        if (!checkPointerEnd())\n            return;\n        /**\n         * We only count this as a tap gesture if the event.target is the same\n         * as, or a child of, this component's element\n         */\n        !isNodeOrChild(visualElement.current, event.target)\n            ? (_b = (_a = visualElement.getProps()).onTapCancel) === null || _b === void 0 ? void 0 : _b.call(_a, event, info)\n            : (_d = (_c = visualElement.getProps()).onTap) === null || _d === void 0 ? void 0 : _d.call(_c, event, info);\n    }\n    function onPointerCancel(event, info) {\n        var _a, _b;\n        if (!checkPointerEnd())\n            return;\n        (_b = (_a = visualElement.getProps()).onTapCancel) === null || _b === void 0 ? void 0 : _b.call(_a, event, info);\n    }\n    function onPointerStart(event, info) {\n        var _a;\n        const latestProps = visualElement.getProps();\n        /**\n         * Ensure we trigger animations before firing event callback\n         */\n        if (latestProps.whileTap && visualElement.animationState) {\n            visualElement.animationState.setActive(AnimationType.Tap, true);\n        }\n        (_a = latestProps.onTapStart) === null || _a === void 0 ? void 0 : _a.call(latestProps, event, info);\n    }\n    const callbackDependencies = [\n        Boolean(onTapStart),\n        Boolean(onTap),\n        Boolean(whileTap),\n        visualElement,\n    ];\n    const startPress = useCallback((event, info) => {\n        removePointerEndListener();\n        if (isPressing.current)\n            return;\n        isPressing.current = true;\n        suspendedTabIndex.current =\n            visualElement.current.getAttribute(\"tabindex\");\n        visualElement.current.setAttribute(\"tabindex\", \"-1\");\n        cancelPointerEndListeners.current = pipe(addPointerEvent(window, \"pointerup\", onPointerUp, eventOptions), addPointerEvent(window, \"pointercancel\", onPointerCancel, eventOptions));\n        onPointerStart(event, info);\n    }, callbackDependencies);\n    usePointerEvent(visualElement, \"pointerdown\", hasPressListeners ? startPress : undefined, eventOptions);\n    const startAccessiblePress = useCallback(() => {\n        const stopKeydownListener = addDomEvent(visualElement.current, \"keydown\", (event) => {\n            if (event.key !== \"Enter\" || isPressing.current)\n                return;\n            isPressing.current = true;\n            cancelPointerEndListeners.current = addDomEvent(visualElement.current, \"keyup\", () => {\n                if (event.key !== \"Enter\" || !checkPointerEnd())\n                    return;\n                fireSyntheticPointerEvent(\"up\", visualElement.getProps().onTap);\n            }, eventOptions);\n            fireSyntheticPointerEvent(\"down\", onPointerStart);\n        });\n        const stopBlurListener = addDomEvent(visualElement.current, \"blur\", () => {\n            stopKeydownListener();\n            stopBlurListener();\n            if (isPressing.current) {\n                fireSyntheticPointerEvent(\"cancel\", onPointerCancel);\n            }\n        });\n    }, callbackDependencies);\n    useDomEvent(visualElement, \"focus\", hasPressListeners ? startAccessiblePress : undefined);\n    useUnmountEffect(removePointerEndListener);\n}\n\nexport { useTapGesture };\n"],"mappings":"AAAA,SAASA,MAAM,EAAEC,WAAW,QAAQ,OAAO;AAC3C,SAASC,aAAa,QAAQ,8BAA8B;AAC5D,SAASC,eAAe,EAAEC,eAAe,QAAQ,iCAAiC;AAClF,SAASC,gBAAgB,QAAQ,iCAAiC;AAClE,SAASC,aAAa,QAAQ,2BAA2B;AACzD,SAASC,YAAY,QAAQ,uBAAuB;AACpD,SAASC,IAAI,QAAQ,mBAAmB;AACxC,SAASC,WAAW,EAAEC,WAAW,QAAQ,6BAA6B;AACtE,SAASC,gBAAgB,QAAQ,0BAA0B;AAE3D,SAASC,yBAAyB,CAACC,IAAI,EAAEC,OAAO,EAAE;EAC9C,IAAI,CAACA,OAAO,EACR;EACJ,MAAMC,qBAAqB,GAAG,IAAIC,YAAY,CAAC,SAAS,GAAGH,IAAI,CAAC;EAChEC,OAAO,CAACC,qBAAqB,EAAEJ,gBAAgB,CAACI,qBAAqB,CAAC,CAAC;AAC3E;AACA;AACA;AACA;AACA;AACA,SAASE,aAAa,OAAwE;EAAA,IAAvE;IAAEC,KAAK;IAAEC,UAAU;IAAEC,WAAW;IAAEC,QAAQ;IAAEC,aAAa;IAAE,GAAGC;EAAM,CAAC;EACxF,MAAMC,iBAAiB,GAAGN,KAAK,IAAIC,UAAU,IAAIC,WAAW,IAAIC,QAAQ;EACxE,MAAMI,UAAU,GAAGzB,MAAM,CAAC,KAAK,CAAC;EAChC,MAAM0B,yBAAyB,GAAG1B,MAAM,CAAC,IAAI,CAAC;EAC9C,MAAM2B,iBAAiB,GAAG3B,MAAM,CAAC,IAAI,CAAC;EACtC;AACJ;AACA;EACI,MAAM4B,YAAY,GAAG;IACjBC,OAAO,EAAE,EAAEV,UAAU,IACjBD,KAAK,IACLE,WAAW,IACXG,KAAK,CAAC,eAAe,CAAC;EAC9B,CAAC;EACD,SAASO,wBAAwB,GAAG;IAChCJ,yBAAyB,CAACK,OAAO,IAAIL,yBAAyB,CAACK,OAAO,EAAE;IACxEL,yBAAyB,CAACK,OAAO,GAAG,IAAI;EAC5C;EACA,SAASC,eAAe,GAAG;IACvBF,wBAAwB,EAAE;IAC1BL,UAAU,CAACM,OAAO,GAAG,KAAK;IAC1B,MAAME,WAAW,GAAGX,aAAa,CAACY,QAAQ,EAAE;IAC5C,IAAID,WAAW,CAACZ,QAAQ,IAAIC,aAAa,CAACa,cAAc,EAAE;MACtDb,aAAa,CAACa,cAAc,CAACC,SAAS,CAAC9B,aAAa,CAAC+B,GAAG,EAAE,KAAK,CAAC;IACpE;IACA,IAAIV,iBAAiB,CAACI,OAAO,KAAK,IAAI,EAAE;MACpCT,aAAa,CAACS,OAAO,CAACO,YAAY,CAAC,UAAU,EAAEX,iBAAiB,CAACI,OAAO,CAAC;IAC7E;IACA,OAAO,CAACxB,YAAY,EAAE;EAC1B;EACA,SAASgC,WAAW,CAACC,KAAK,EAAEC,IAAI,EAAE;IAC9B,IAAIC,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAEC,EAAE;IAClB,IAAI,CAACb,eAAe,EAAE,EAClB;IACJ;AACR;AACA;AACA;IACQ,CAAC9B,aAAa,CAACoB,aAAa,CAACS,OAAO,EAAES,KAAK,CAACM,MAAM,CAAC,GAC7C,CAACH,EAAE,GAAG,CAACD,EAAE,GAAGpB,aAAa,CAACY,QAAQ,EAAE,EAAEd,WAAW,MAAM,IAAI,IAAIuB,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACI,IAAI,CAACL,EAAE,EAAEF,KAAK,EAAEC,IAAI,CAAC,GAChH,CAACI,EAAE,GAAG,CAACD,EAAE,GAAGtB,aAAa,CAACY,QAAQ,EAAE,EAAEhB,KAAK,MAAM,IAAI,IAAI2B,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACE,IAAI,CAACH,EAAE,EAAEJ,KAAK,EAAEC,IAAI,CAAC;EACpH;EACA,SAASO,eAAe,CAACR,KAAK,EAAEC,IAAI,EAAE;IAClC,IAAIC,EAAE,EAAEC,EAAE;IACV,IAAI,CAACX,eAAe,EAAE,EAClB;IACJ,CAACW,EAAE,GAAG,CAACD,EAAE,GAAGpB,aAAa,CAACY,QAAQ,EAAE,EAAEd,WAAW,MAAM,IAAI,IAAIuB,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACI,IAAI,CAACL,EAAE,EAAEF,KAAK,EAAEC,IAAI,CAAC;EACpH;EACA,SAASQ,cAAc,CAACT,KAAK,EAAEC,IAAI,EAAE;IACjC,IAAIC,EAAE;IACN,MAAMT,WAAW,GAAGX,aAAa,CAACY,QAAQ,EAAE;IAC5C;AACR;AACA;IACQ,IAAID,WAAW,CAACZ,QAAQ,IAAIC,aAAa,CAACa,cAAc,EAAE;MACtDb,aAAa,CAACa,cAAc,CAACC,SAAS,CAAC9B,aAAa,CAAC+B,GAAG,EAAE,IAAI,CAAC;IACnE;IACA,CAACK,EAAE,GAAGT,WAAW,CAACd,UAAU,MAAM,IAAI,IAAIuB,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACK,IAAI,CAACd,WAAW,EAAEO,KAAK,EAAEC,IAAI,CAAC;EACxG;EACA,MAAMS,oBAAoB,GAAG,CACzBC,OAAO,CAAChC,UAAU,CAAC,EACnBgC,OAAO,CAACjC,KAAK,CAAC,EACdiC,OAAO,CAAC9B,QAAQ,CAAC,EACjBC,aAAa,CAChB;EACD,MAAM8B,UAAU,GAAGnD,WAAW,CAAC,CAACuC,KAAK,EAAEC,IAAI,KAAK;IAC5CX,wBAAwB,EAAE;IAC1B,IAAIL,UAAU,CAACM,OAAO,EAClB;IACJN,UAAU,CAACM,OAAO,GAAG,IAAI;IACzBJ,iBAAiB,CAACI,OAAO,GACrBT,aAAa,CAACS,OAAO,CAACsB,YAAY,CAAC,UAAU,CAAC;IAClD/B,aAAa,CAACS,OAAO,CAACO,YAAY,CAAC,UAAU,EAAE,IAAI,CAAC;IACpDZ,yBAAyB,CAACK,OAAO,GAAGvB,IAAI,CAACL,eAAe,CAACmD,MAAM,EAAE,WAAW,EAAEf,WAAW,EAAEX,YAAY,CAAC,EAAEzB,eAAe,CAACmD,MAAM,EAAE,eAAe,EAAEN,eAAe,EAAEpB,YAAY,CAAC,CAAC;IAClLqB,cAAc,CAACT,KAAK,EAAEC,IAAI,CAAC;EAC/B,CAAC,EAAES,oBAAoB,CAAC;EACxB9C,eAAe,CAACkB,aAAa,EAAE,aAAa,EAAEE,iBAAiB,GAAG4B,UAAU,GAAGG,SAAS,EAAE3B,YAAY,CAAC;EACvG,MAAM4B,oBAAoB,GAAGvD,WAAW,CAAC,MAAM;IAC3C,MAAMwD,mBAAmB,GAAGhD,WAAW,CAACa,aAAa,CAACS,OAAO,EAAE,SAAS,EAAGS,KAAK,IAAK;MACjF,IAAIA,KAAK,CAACkB,GAAG,KAAK,OAAO,IAAIjC,UAAU,CAACM,OAAO,EAC3C;MACJN,UAAU,CAACM,OAAO,GAAG,IAAI;MACzBL,yBAAyB,CAACK,OAAO,GAAGtB,WAAW,CAACa,aAAa,CAACS,OAAO,EAAE,OAAO,EAAE,MAAM;QAClF,IAAIS,KAAK,CAACkB,GAAG,KAAK,OAAO,IAAI,CAAC1B,eAAe,EAAE,EAC3C;QACJpB,yBAAyB,CAAC,IAAI,EAAEU,aAAa,CAACY,QAAQ,EAAE,CAAChB,KAAK,CAAC;MACnE,CAAC,EAAEU,YAAY,CAAC;MAChBhB,yBAAyB,CAAC,MAAM,EAAEqC,cAAc,CAAC;IACrD,CAAC,CAAC;IACF,MAAMU,gBAAgB,GAAGlD,WAAW,CAACa,aAAa,CAACS,OAAO,EAAE,MAAM,EAAE,MAAM;MACtE0B,mBAAmB,EAAE;MACrBE,gBAAgB,EAAE;MAClB,IAAIlC,UAAU,CAACM,OAAO,EAAE;QACpBnB,yBAAyB,CAAC,QAAQ,EAAEoC,eAAe,CAAC;MACxD;IACJ,CAAC,CAAC;EACN,CAAC,EAAEE,oBAAoB,CAAC;EACxBxC,WAAW,CAACY,aAAa,EAAE,OAAO,EAAEE,iBAAiB,GAAGgC,oBAAoB,GAAGD,SAAS,CAAC;EACzFlD,gBAAgB,CAACyB,wBAAwB,CAAC;AAC9C;AAEA,SAASb,aAAa"},"metadata":{},"sourceType":"module","externalDependencies":[]}